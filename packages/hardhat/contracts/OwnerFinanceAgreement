// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "./FinanceNFT.sol";
import "./SellerNFT.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract OwnerFinancingAgreement is Ownable {
    using SafeMath for uint256;

    address public financeNFTAddress;
    address public sellerNFTAddress;

    FinanceNFT private financeNFT;
    SellerNFT private sellerNFT;

    IERC20 public currencyToken; // The ERC20 token used for payments.

    struct FinancingTerms {
        uint256 price;
        uint256 downPayment;
        uint256 interestRate; // Percentage times 100 (i.e. 5.5% = 550)
        uint256 termInMonths;
        uint256 maxMonthsPastDue;
    }

    struct Offer {
        address buyer;
        FinancingTerms terms;
    }

    // Mapping to keep track of offers. The seller can review these before approval.
    mapping(address => Offer) public offers;

    // Initialize the financing agreement with default terms set by the seller.
    FinancingTerms public defaultFinancingTerms;

    // Boolean to check if the financing has been initiated
    bool public isFinancingInitiated = false;

    // The approved buyer's address
    address public approvedBuyer;

    // Events
    event OfferSubmitted(address indexed buyer, FinancingTerms terms);
    event OfferApproved(address indexed buyer, FinancingTerms terms);
    event PaymentMade(address indexed buyer, uint256 amount);
    event FinancingDefaulted(address indexed buyer);
    event SellerNFTMinted(address indexed seller, uint256 tokenId);
    event FinanceNFTMinted(address indexed buyer, uint256 tokenId);

    constructor(
        address _financeNFTAddress,
        address _sellerNFTAddress,
        address _currencyTokenAddress,
        FinancingTerms memory _defaultFinancingTerms
    ) {
        financeNFTAddress = _financeNFTAddress;
        sellerNFTAddress = _sellerNFTAddress;
        currencyToken = IERC20(_currencyTokenAddress);

        financeNFT = FinanceNFT(_financeNFTAddress);
        sellerNFT = SellerNFT(_sellerNFTAddress);

        // Set default financing terms
        defaultFinancingTerms = _defaultFinancingTerms;
    }

    function submitOffer(FinancingTerms memory _terms) external {
        require(!isFinancingInitiated, "Financing already initiated");
        offers[msg.sender] = Offer({
            buyer: msg.sender,
            terms: _terms
        });
        emit OfferSubmitted(msg.sender, _terms);
    }

    function approveOffer(address _buyer) external onlyOwner {
        require(!isFinancingInitiated, "Financing already initiated");
        Offer memory offer = offers[_buyer];
        require(offer.buyer == _buyer, "Offer not found");

        // Mint FinanceNFT for the buyer
        uint256 financeNFTId = financeNFT.mint(_buyer);
        
        // Mint SellerNFT for the owner (seller)
        uint256 sellerNFTId = sellerNFT.mint(owner());

        // Update contract state
        approvedBuyer = _buyer;
        isFinancingInitiated = true;

        emit OfferApproved(_buyer, offer.terms);
        emit SellerNFTMinted(owner(), sellerNFTId);
        emit FinanceNFTMinted(_buyer, financeNFTId);
    }

        event PaymentReceived(address indexed buyer, uint256 amount);
    event DefaultHandled(address indexed buyer, uint256 monthsPastDue);

    // Function to accept monthly payments
    function makePayment() external {
        require(isFinancingInitiated, "Financing not initiated");
        require(msg.sender == approvedBuyer, "Only the approved buyer can make payments");

        FinancingTerms memory terms = offers[msg.sender].terms;
        require(terms.monthlyPayment > 0, "Invalid payment terms");

        uint256 amountDue = terms.monthlyPayment;
        require(currencyToken.transferFrom(msg.sender, address(this), amountDue), "Transfer failed");

        // Update contract and buyer state (for simplicity, not accounting for exact monthly timing)
        monthsPaid += 1;
        emit PaymentReceived(msg.sender, amountDue);
    }

    // Function to handle defaults
    function handleDefault() external onlyOwner {
        require(isFinancingInitiated, "Financing not initiated");

        uint256 monthsPastDue = monthsRequired - monthsPaid;
        require(monthsPastDue >= defaultThresholdMonths, "Default conditions not met");

        // Revert ownership of FinanceNFT to the seller
        financeNFT.transferFrom(approvedBuyer, owner(), financeNFT.getTokenId(approvedBuyer));

        emit DefaultHandled(approvedBuyer, monthsPastDue);

        // Reset contract state (for simplicity, we're not handling reclaiming of funds or property here)
        delete offers[approvedBuyer];
        isFinancingInitiated = false;
        monthsPaid = 0;
    }

        event FinanceNFTTransferred(address indexed from, address indexed to, uint256 tokenId);
    event SellerNFTTransferred(address indexed from, address indexed to, uint256 tokenId);

    // Function for the approved buyer to transfer their FinanceNFT
    function transferFinanceNFT(address newBuyer) external {
        require(msg.sender == approvedBuyer, "Only the approved buyer can transfer the FinanceNFT");

        uint256 tokenId = financeNFT.getTokenId(msg.sender);

        financeNFT.transferFrom(msg.sender, newBuyer, tokenId);

        approvedBuyer = newBuyer;
        emit FinanceNFTTransferred(msg.sender, newBuyer, tokenId);
    }

    // Function for the seller to transfer their SellerNFT
    function transferSellerNFT(address newOwner) external onlyOwner {
        uint256 tokenId = sellerNFT.getTokenId(owner());

        sellerNFT.transferFrom(owner(), newOwner, tokenId);

        transferOwnership(newOwner);
        emit SellerNFTTransferred(owner(), newOwner, tokenId);
    }

    event OfferReceived(address indexed from, uint256 offerAmount, uint256 indexed propertyId);

    mapping(uint256 => uint256) public maximumMonthsPastDue; // Maximum months past due per property

    // Function to set maximumMonthsPastDue for a property
    function setMaxMonthsPastDue(uint256 propertyId, uint256 months) external onlyOwner {
        maximumMonthsPastDue[propertyId] = months;
    }

    // Function to make an offer by a potential buyer
    function makeOffer(uint256 propertyId, uint256 offerAmount) external {
        // Logic to handle offer
        emit OfferReceived(msg.sender, offerAmount, propertyId);
    }

    // Function for the seller to accept an offer
    function acceptOffer(address buyer, uint256 propertyId, uint256 acceptedAmount) external onlyOwner {
        // Accept the offer and initiate the agreement
        approvedBuyer = buyer;
    }

    // Circuit breaker for emergency stop by the owner
    bool public stopped = false;
    event CircuitBreakerToggled(bool stopped);

    // Circuit breaker modifiers
    modifier stopInEmergency { require(!stopped, "Contract is stopped by owner"); _; }
    modifier onlyInEmergency { require(stopped, "Contract is not stopped"); _; }

    // Function to toggle circuit breaker
    function toggleCircuitBreaker() external onlyOwner {
        stopped = !stopped;
        emit CircuitBreakerToggled(stopped);
    }

    // Make sure to use `stopInEmergency` modifier for sensitive external/public functions




